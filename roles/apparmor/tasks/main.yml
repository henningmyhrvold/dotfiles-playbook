---
- name: Install required packages for AppArmor and related tools
  community.general.pacman:
    name:
      - apparmor
      - audit
      - python-notify2
      - python-psutil
    state: present

- name: Create audit group if it does not exist
  ansible.builtin.group:
    name: audit
    system: true

- name: Add user to audit group
  ansible.builtin.user:
    name: "{{ apparmor_user }}"
    groups: audit
    append: true

- name: Configure auditd to use audit group for log access
  ansible.builtin.lineinfile:
    path: /etc/audit/auditd.conf
    regexp: '^log_group\s*='
    line: 'log_group = audit'
    state: present

- name: Enable and start auditd service
  ansible.builtin.systemd:
    name: auditd.service
    enabled: true
    state: started

- name: Enable and start apparmor service
  ansible.builtin.systemd:
    name: apparmor.service
    enabled: true
    state: started

- name: Enable profile caching in AppArmor parser configuration
  ansible.builtin.replace:
    path: /etc/apparmor/parser.conf
    regexp: '^#write-cache$'
    replace: 'write-cache'

- name: Detect if using UKI
  ansible.builtin.command: bootctl status
  register: boot_status
  changed_when: false

- name: Set fact for UKI usage
  ansible.builtin.set_fact:
    is_uki: "{{ 'systemd-stub' in boot_status.stdout }}"

- name: Set dummy current_options_list for traditional skip
  ansible.builtin.set_fact:
    current_options_list: {'results': []}
  when: is_uki

- name: Handle traditional boot entries if not UKI
  block:
    - name: Set entry directory
      ansible.builtin.set_fact:
        entry_dir: "{{ esp_mount }}/loader/entries"

    - name: Find all boot entry files
      ansible.builtin.find:
        paths: "{{ entry_dir }}"
        patterns: '*.conf'
        file_type: file
      register: boot_entries

    - name: Fail if no boot entry files found
      ansible.builtin.fail:
        msg: "No boot entry files found in {{ entry_dir }}. Verify systemd-boot configuration and esp_mount variable."
      when: boot_entries.matched == 0

    - name: Get current kernel options from each systemd-boot entry
      ansible.builtin.command: grep '^options' {{ item.path }}
      loop: "{{ boot_entries.files }}"
      register: current_options_list
      changed_when: false
      ignore_errors: true

    - name: Append LSM kernel parameter to each entry if not present
      ansible.builtin.lineinfile:
        path: "{{ item.item.path }}"
        regexp: '^options'
        line: "options {{ (item.stdout | regex_replace('^options\\s*', '')) + ' lsm=landlock,lockdown,yama,integrity,apparmor,bpf' if item.stdout else 'lsm=landlock,lockdown,yama,integrity,apparmor,bpf' }}"
        state: present
        create: false
      loop: "{{ current_options_list.results }}"
      loop_control:
        label: "{{ item.item.path }} - LSM"
      when: '"lsm=landlock,lockdown,yama,integrity,apparmor,bpf" not in item.stdout'
      notify: Reboot system

    - name: Append apparmor=1 kernel parameter to each entry if not present
      ansible.builtin.lineinfile:
        path: "{{ item.item.path }}"
        regexp: '^options'
        line: "options {{ (item.stdout | regex_replace('^options\\s*', '')) + ' apparmor=1' if item.stdout else 'apparmor=1' }}"
        state: present
        create: false
      loop: "{{ current_options_list.results }}"
      loop_control:
        label: "{{ item.item.path }} - apparmor=1"
      when: '"apparmor=1" not in item.stdout'
      notify: Reboot system

    - name: Append security=apparmor kernel parameter to each entry if not present
      ansible.builtin.lineinfile:
        path: "{{ item.item.path }}"
        regexp: '^options'
        line: "options {{ (item.stdout | regex_replace('^options\\s*', '')) + ' security=apparmor' if item.stdout else 'security=apparmor' }}"
        state: present
        create: false
      loop: "{{ current_options_list.results }}"
      loop_control:
        label: "{{ item.item.path }} - security=apparmor"
      when: '"security=apparmor" not in item.stdout'
      notify: Reboot system
  when: not is_uki

- name: Handle UKI kernel parameters if using UKI
  block:
    - name: Read current kernel cmdline
      ansible.builtin.slurp:
        src: /etc/kernel/cmdline
      register: current_cmdline_slurp
      ignore_errors: true

    - name: Set current cmdline fact
      ansible.builtin.set_fact:
        current_cmdline: "{{ current_cmdline_slurp.content | b64decode | default('') | trim }}"

    - name: Set new cmdline with missing AppArmor parameters
      ansible.builtin.set_fact:
        new_cmdline: "{{ current_cmdline + ' ' + (apparmor_params | reject('in', current_cmdline.split()) | join(' ')) | trim }}"

    - name: Write updated kernel cmdline if changed
      ansible.builtin.copy:
        content: "{{ new_cmdline }}\n"
        dest: /etc/kernel/cmdline
        mode: '0644'
      when: new_cmdline != current_cmdline
      notify: Reboot system

    - name: Regenerate UKI if cmdline changed
      ansible.builtin.command: mkinitcpio -P
      when: new_cmdline != current_cmdline
      notify: Reboot system
  when: is_uki

- name: Set user home directory
  ansible.builtin.set_fact:
    user_home: "{{ '/root' if apparmor_user == 'root' else '/home/' + apparmor_user }}"

- name: Ensure autostart directory exists
  ansible.builtin.file:
    path: "{{ user_home }}/.config/autostart"
    state: directory
    owner: "{{ apparmor_user }}"
    group: "{{ apparmor_user }}"
    mode: '0755'

- name: Deploy AppArmor notify desktop file for notifications
  ansible.builtin.template:
    src: apparmor-notify.desktop.j2
    dest: "{{ user_home }}/.config/autostart/apparmor-notify.desktop"
    owner: "{{ apparmor_user }}"
    group: "{{ apparmor_user }}"
    mode: '0644'
